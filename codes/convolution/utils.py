from data import *
from astropy.cosmology import FlatLambdaCDM
import astropy.constants as con

cosmo        = FlatLambdaCDM(H0=hubble*100, Om0=Omega0)

def bolometricLF(z):
double P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14;
double xsi = log10((1. + z)/(1. + 2.));
double beta_min = 1.3;
	if (FIT_KEY==5) beta_min = 0.02;


// full model
if (FIT_KEY==0) {P0=-4.8250643; P1=13.035753;   P2=0.63150872; P3=-11.763560; P4=-14.249833; 
				 P5=0.41698725; P6=-0.62298947; P7=2.1744386;  P8=1.4599393;  P9=-0.79280099; 
				 P10=0.;P11=0.;P12=0.;P13=0.;P14=0.;}

// double power-law forms
if (FIT_KEY <= 5) {
	double phi_star = P0;
		// phi_star is constant as a function of redshift
	double l_star   = P1 + P2*xsi + P3*xsi*xsi + P4*xsi*xsi*xsi;
		// l_star evolves (luminosity evolution) as a cubic polynomial in the 
		//    convenient variable xsi=log_{10}((1+z)/(1+z_ref)) with z_ref=2
	double gamma_1  = P5 * pow(10.,xsi*P6);
		// gamma_1 the faint-end slope -- optionally evolves with redshift
	double gamma_2  = 2.0 * P7 / (pow(10.,xsi*P8) + pow(10.,xsi*P9));
		// gamma_2 the bright-end slope -- optionally evolves with redshift
		if (gamma_2 < beta_min) gamma_2 = beta_min;
			// cap the bright-end evolution to prevent unphysical divergence
	double x = log_l_bol - l_star;
	if (FIT_KEY==5) {return pow(10.,(phi_star - gamma_1*x - pow(10.,x*gamma_2)/log(10.)));}
	return pow(10.,phi_star - log10(pow(10.,x*gamma_1) + pow(10.,x*gamma_2)));
}

	return Phi_bol

#return the lognormal dispersion in bolometric corrections for a given band and luminosity
def band_dispersion(L_bol,nu):
	x = L_bol - 9.

	sx_floor = 0.050 #minimum value of dispersion to enforce
	if nu == 0.:  return 0.01
	if nu < 0.:
		if nu== -1.: s0, beta, s1 = 0.08, -0.20, 0.065
		if nu== -2.: s0, beta, s1 = 0.03, -0.10, 0.095
		if nu== -3.: s0, beta, s1 = 0.01,  0.10, 0.060
		if nu== -4.: s0, beta, s1 = 0.04,  0.05, 0.080
		return s0 * np.power(10.,beta*x) + s1
	# interpolate between the known ranges, and (conservatively) hold constant 
	#   outside of them. roughly consistent with Richards et al. 2006 dispersions, 
	#   but uncertainty in how large the dispersions should be yields ~10% uncertainties 
	#   between 15microns and 10keV, and larger outside those ranges (since the 
	#   dispersions there are poorly determined) -- still, the lognormal dispersions 
	#   vary relatively weakly over observed ranges, so these are probably the 
	#   maximal uncertainties due to this effect
	nu15 = 2.00e13
	nuBB = 6.81818e14
	nuSX = 0.5 * 2.418e17
	nuHX = 10. * 2.418e17
	if (nu < nu15): 
		s0, beta, s1 = 0.03, -0.10, 0.095 
		return s0 * np.power(10.,beta*x)+s1
	if (nu >=nuHX): 
		s0, beta, s1 = 0.04, 0.05, 0.080 
		return s0 * np.power(10.,beta*x)+s1
	if (nu >= nu15) and (nu< nuBB): 
		s0, beta, s1 = 0.03, -0.10, 0.095
		sf1 = s0 * np.power(10.,beta*x) + s1
		s0, beta, s1 = 0.08, -0.20, 0.065
		sf2 = s0 * np.power(10.,beta*x) + s1
		sx = sf1 + (sf2-sf1) * (np.log10(nu/nu15)/np.log10(nuBB/nu15))
		if (sx<=sx_floor): sx=sx_floor
		return sx
	if (nu >= nuBB) and (nu< nuSX): 
		s0, beta, s1 = 0.08, -0.20, 0.065
		sf1 = s0 * np.power(10.,beta*x) + s1
		s0, beta, s1 = 0.01, 0.10, 0.060
		sf2 = s0 * np.power(10.,beta*x) + s1
		sx = sf1 + (sf2-sf1) * (np.log10(nu/nu15)/np.log10(nuBB/nu15))
		if (sx<=sx_floor): sx=sx_floor
		return sx
	if (nu >= nuSX) and (nu< nuHX): 
		s0, beta, s1 = 0.01, 0.10, 0.060
		sf1 = s0 * np.power(10.,beta*x) + s1
		s0, beta, s1 = 0.04, 0.05, 0.080
		sf2 = s0 * np.power(10.,beta*x) + s1
		sx = sf1 + (sf2-sf1) * (np.log10(nu/nu15)/np.log10(nuBB/nu15))
		if (sx<=sx_floor): sx=sx_floor
		return sx

def pei_dust_extinction(lambda_in_microns):
	key='SMC' #MW,LMC,SMC
	xsi = 0.0 * lambda_in_microns
	if (key=='MW'):
  		a = np.array([165., 14., 0.045, 0.002, 0.002, 0.012])
  		l = np.array([0.047, 0.08, 0.22, 9.7, 18., 25.])
  		b = np.array([90., 4.00, -1.95, -1.95, -1.80, 0.00])
  		n = np.array([2.0, 6.5, 2.0, 2.0, 2.0, 2.0])
  		R_V = 3.08
  		for i in range(6): 
  			xsi += a[i]/( np.power(lambda_in_microns/l[i],n[i]) + np.power(l[i]/lambda_in_microns,n[i]) + b[i] )

	if (key=='LMC'):
		a = np.array([175., 19., 0.023, 0.005, 0.006, 0.020])
		l = np.array([0.046, 0.08, 0.22, 9.7, 18., 25.])
		b = np.array([90., 5.50, -1.95, -1.95, -1.80, 0.00])
		n = np.array([2.0, 4.5, 2.0, 2.0, 2.0, 2.0])
		R_V = 3.16
  		for i in range(6):
  			xsi += a[i]/( np.power(lambda_in_microns/l[i],n[i]) + np.power(l[i]/lambda_in_microns,n[i]) + b[i] )

	if (key=='SMC'):
		a = np.array([185., 27., 0.005, 0.010, 0.012, 0.030])
		l = np.array([0.042, 0.08, 0.22, 9.7, 18., 25.])
		b = np.array([90., 5.50, -1.95, -1.95, -1.80, 0.00])
		n = np.array([2.0, 4.0, 2.0, 2.0, 2.0, 2.0])
		R_V = 2.93
		for i in range(6):
			xsi += a[i]/( np.power(lambda_in_microns/l[i],n[i]) + np.power(l[i]/lambda_in_microns,n[i]) + b[i] )

	#R_lam = (1.0 + R_V) * xsi;
	return xsi

def morrison_photoeletric_absorption(x):
	if (x<0.03):
		c0, c1, c2 = 17.3, 608.1, -2150.0
		return (1.0e-24)*(c0+c1*0.03+c2*0.03*0.03)/(0.03*0.03*0.03)*np.power(x/0.03,-2.43)
	elif (x>=0.03) and (x<0.1):
		c0, c1, c2 = 17.3, 608.1, -2150.0
	elif (x>=0.1) and (x<0.284):
		c0, c1, c2 = 34.6, 267.9, -476.1
	elif (x>=0.284) and (x<0.4):
		c0, c1, c2 = 78.1, 18.8, 4.3
	elif (x>=0.4) and (x<0.532):
		c0, c1, c2 = 71.4, 66.8, -51.4
	elif (x>=0.532) and (x<0.707):
		c0, c1, c2 =  95.5, 45.8, 1.1
	elif (x>=0.707) and (x<0.867):
		c0, c1, c2 = 308.9, 80.6, 4.0
	elif (x>=0.867) and (x<1.303):
		c0, c1, c2 = 120.6, 69.3, 7.7
	elif (x>=1.303) and (x<1.840):
		c0, c1, c2 = 141.3, 46.8, 1.5
	elif (x>=1.840) and (x<2.471):
		c0, c1, c2 = 202.7, 04.7, 7.0
	elif (x>=2.471) and (x<3.210):
		c0, c1, c2 = 342.7, 18.7, 0.0
	elif (x>=3.210) and (x<4.038):
		c0, c1, c2 = 352.2, 18.7, 0.0
	elif (x>=4.038) and (x<7.111):
		c0, c1, c2 = 433.9, -2.4, 0.75
	elif (x>=7.111) and (x<8.331):
		c0, c1, c2 = 629.0, 30.9, 0.0
	elif (x>=8.331) and (x<10.00):
		c0, c1, c2 = 701.2, 25.2, 0.0
	else:	
		# extrapolate the > 10 keV results to higher frequencies
		c0, c1, c2 = 701.2, 25.2, 0.0
	#Use these coefficients to calculate the cross section per hydrogen atom
	return (1.0e-24)*(c0+c1*x+c2*x**2)/(x**3); #cm^2

def cross_section(nu):
	sigma=0.
	metallicity_over_solar = 1.
	keV_in_Hz = 2.418e17
	micron  = 1.0e-6
	'''
  	; For optical-IR regions, we use the Pei numerical approximations below.
  	;
  	; xsi = tau(lambda)/tau(B) is the ratio of extinction at lambda to the 
  	;    extinction in the B-band. 
  	; k = 10^21 (tau_B / NH)   (NH in cm^2) gives the dimensionless gas-to-dust
  	;    ratio, with k=0.78 for MW, k=0.16 for LMC, k=0.08 for SMC.
  	;    k is INDEPENDENT of the grain properties, and seems to scale rougly
  	;    linearly with metallicity
  	; so, for now, assume solar metallicity and k = k_MW = 0.78. we can rescale later.
  	;
  	; tau_B = ( NH / (10^21 cm^-2) ) * k --> SIGMA_B = k*10^-21  cm^2
  	; tau_lambda = xsi * tau_B --> SIGMA = xsi * SIGMA_B
  	;
  	; k = 0.78 for the MW
  	; k = 0.08 for the SMC, approximately in line with the MW/LMC/SMC metallicity 
  	;  sequence, so we take a k_MW then scaled by the metallicity
	'''
	k_dust_to_gas = 0.78 * metallicity_over_solar
	lambda_microns = con.c.value / nu / micron
	if (nu < 0.03*keV_in_Hz): 
		sigma += pei_dust_extinction(lambda_microns) * k_dust_to_gas * 1.0e-21


	'''
  	For 0.03 keV < E < 10 keV  
  	  (7.2e15 < nu[Hz] < 2.4e18  or   1.2 < lambda[Angstroms] < 413)
  	  we use the photoelectric absorption cross sections of 
  	  Morrison & McCammon (1983)
  	    NOTE: these assume solar abundances and no ionization, 
  	            the appropriate number probably scales linearly with both
  	  (this is all for the COMPTON THIN regime)
	'''
	if nu > (0.03*keV_in_Hz*1.362/3.0): # above Lyman edge
		sigma += morrison_photoeletric_absorption(nu/keV_in_Hz)

	'''
	Floor in cross-section set by non-relativistic (achromatic) Thompson scattering
	 (technically want to calculate self-consistently for the ionization state of the 
	  gas, but for reasonable values this agrees well with more detailed calculations 
	  including line effects from Matt, Pompilio, & La Franca; since we don't know the 
	  state of the gas (& have already calculated the inner reflection component), this
	  is the best guess)
	'''
	sigma += 6.65e-25
	return sigma

def return_tau(log_NH,nu):
	if nu <= 0.:
		if (nu== 0.): return 0.	#no bolometric attenuation
		if (nu==-1.): return np.power(10.,log_NH)*cross_section(con.c.value/(4400.0e-10))
		# call at nu_B
		if (nu==-2.): return np.power(10.,log_NH)*cross_section(con.c.value/(15.0e-6))	 
		# call at 15microns

		if (nu==-3.):
			NH = np.array([ 16.00, 16.10, 16.20, 16.30, 16.40, 16.50, 16.60, 16.70, 16.80, 16.90, 17.00, 17.10, 17.20, 17.30, 17.40, 17.50, 17.60, 17.70, 17.80, 17.90, 18.00, 18.10, 18.20, 18.30, 18.40, 18.50,
			18.60, 18.70, 18.80, 18.90, 19.00, 19.10, 19.20, 19.30, 19.40, 19.50, 19.60, 19.70, 19.80, 19.90, 20.00, 20.10, 20.20, 20.30, 20.40, 20.50, 20.60, 20.70, 20.80, 20.90, 21.00, 21.10,
			21.20, 21.30, 21.40, 21.50, 21.60, 21.70, 21.80, 21.90, 22.00, 22.10, 22.20, 22.30, 22.40, 22.50, 22.60, 22.70, 22.80, 22.90, 23.00, 23.10, 23.20, 23.30, 23.40, 23.50, 23.60, 23.70,
			23.80, 23.90, 24.00, 24.10, 24.20, 24.30, 24.40, 24.50, 24.60, 24.70, 24.80, 24.90, 25.00, 25.10, 25.20, 25.30, 25.40, 25.50, 25.60, 25.70, 25.80, 25.90, 26.00])
			tau = np.array([-0.00000124, -0.00000158,    -0.00000197,    -0.00000249,    -0.00000313,    -0.00000393,   -0.00000494, -0.00000624,    -0.00000784,    -0.00000989,    -0.00001245,    -0.00001566,
			-0.00001973,    -0.00002483,    -0.00003127,    -0.00003935,    -0.00004955,    -0.00006236, -0.00007852,    -0.00009884,    -0.00012443,    -0.00015666,    -0.00019722, -0.00024827,   
			-0.00031253,    -0.00039344,    -0.00049527,    -0.00062347,    -0.00078482, -0.00098790,   -0.00124348,    -0.00156514,    -0.00196988,    -0.00247909, -0.00311972,    -0.00392549,   
			-0.00493867,    -0.00621233,    -0.00781276,    -0.00982293, -0.01234610,    -0.01551090,   -0.01947660,    -0.02443970,    -0.03064190, -0.03837750,    -0.04800200,    -0.05994050,   
			-0.07469200,    -0.09283250,    -0.11500600, -0.14191000,    -0.17425400,    -0.21271700,   -0.25787899,    -0.31016999, -0.36986199,    -0.43716601,    -0.51242900,    -0.59641999,   
			-0.69052601,    -0.79681402, -0.91799599,    -1.05745995,    -1.21945000,    -1.40935004,   
			-1.63397002, -1.90190005,    -2.22390008,    -2.61347008,    -3.08738995,    -3.66647005,   -4.37638998, -5.24916983,    -6.32518005,    -7.65556002,    -9.30533981,   -11.35690022,
			-13.40830040,   -15.45989990,   -17.51140022,   -19.56290054,   -21.61440086, -23.66589928,  -25.71750069,   -27.76889992,   -29.82049942,   -31.87199974, -33.92350006,   -35.97499847,
			-38.02650070,   -40.07799911,   -42.12919998, -44.15449905,   -46.17983627,  -48.20517349,   -50.23051071,   -52.25585175, -54.28115082,   -56.30648804,   -58.33182526])

			if (log_NH < NH[0]):  tau_f = tau[0]  + (tau[1]-tau[0])   *(log_NH-NH[0])/(NH[1]-NH[0])
			if (log_NH > NH[99]): tau_f = tau[99] + (tau[100]-tau[99])*(log_NH-NH[99])/(NH[100]-NH[99])
			if (log_NH>=NH[0]) and (log_NH<=NH[99]): 
				n0 = int((log_NH-NH[0])/0.10)
				tau_f  = tau[n0] + (tau[n0+1]-tau[n0])*(log_NH-NH[n0])/(NH[n0+1]-NH[n0])
			if (tau_f >= 0.): tau_f=0.
			return -tau_f * np.log(10.)

		if (nu==-4.):
			NH = np.array([16.00, 16.10, 16.20, 16.30, 16.40, 16.50, 16.60, 16.70, 16.80, 16.90, 17.00, 17.10, 17.20, 17.30, 17.40, 17.50, 17.60, 17.70, 17.80, 17.90, 18.00, 18.10, 18.20, 18.30, 18.40, 18.50,
			18.60, 18.70, 18.80, 18.90, 19.00, 19.10, 19.20, 19.30, 19.40, 19.50, 19.60, 19.70, 19.80, 19.90, 20.00, 20.10, 20.20, 20.30, 20.40, 20.50, 20.60, 20.70, 20.80, 20.90, 21.00, 21.10,
			21.20, 21.30, 21.40, 21.50, 21.60, 21.70, 21.80, 21.90, 22.00, 22.10, 22.20, 22.30, 22.40, 22.50, 22.60, 22.70, 22.80, 22.90, 23.00, 23.10, 23.20, 23.30, 23.40, 23.50, 23.60, 23.70,
			23.80, 23.90, 24.00, 24.10, 24.20, 24.30, 24.40, 24.50, 24.60, 24.70, 24.80, 24.90, 25.00, 25.10, 25.20, 25.30, 25.40, 25.50, 25.60, 25.70, 25.80, 25.90, 26.00])
			tau = np.array([-0.00000005, -0.00000005,    -0.00000005,    -0.00000008,    -0.00000010,    -0.00000013,   -0.00000016, -0.00000021,    -0.00000026,    -0.00000031,    -0.00000041,    -0.00000052,
			-0.00000065,    -0.00000080,    -0.00000101,    -0.00000127,    -0.00000160,    -0.00000202, -0.00000256,    -0.00000321,    -0.00000404,    -0.00000510,    -0.00000642, -0.00000808,   
			-0.00001017,    -0.00001281,    -0.00001613,    -0.00002030,    -0.00002555, -0.00003218,    -0.00004051,    -0.00005100,    -0.00006420,    -0.00008082, -0.00010174,    -0.00012808,   
			-0.00016122,    -0.00020297,    -0.00025549,    -0.00032160, -0.00040484,    -0.00050955,   -0.00064138,    -0.00080723,    -0.00101594, -0.00127847,    -0.00160871,    -0.00202394,   
			-0.00254596,    -0.00320199,    -0.00402598, -0.00506041,    -0.00635801,    -0.00798424,   -0.01002010,    -0.01256490, -0.01574020,    -0.01969330,    -0.02460080,    -0.03067190,   
			-0.03814980,    -0.04731170, -0.05846370,    -0.07193180,    -0.08804700,    -0.10712300,   -0.12943600, -0.15520699,    -0.18461201,    -0.21782200,    -0.25508299,    -0.29682499,   
			-0.34375799, -0.39693701,    -0.45780700,    -0.52823699,    -0.61060297,    -0.70790398,   -0.82392102,    -0.96342301,    -1.13239002,    -1.33829999,    -1.59043002,    -1.90021002,
			-2.28153992,    -2.75111008,    -3.32871008,    -4.03739023,    -4.90411997, -5.96181011,   -7.25338984,    -8.54498959,    -9.83658981,   -11.12819958,   -12.41979980, -13.71140003,  
			-15.00300026,   -16.29459953,   -17.58620071,   -18.87779999, -20.16939926])
			if (log_NH < NH[0]):  tau_f = tau[0]  + (tau[1]-tau[0])   *(log_NH-NH[0])/(NH[1]-NH[0])
			if (log_NH > NH[99]): tau_f = tau[99] + (tau[100]-tau[99])*(log_NH-NH[99])/(NH[100]-NH[99])
			if (log_NH>=NH[0]) and (log_NH<=NH[99]): 
				n0 = int((log_NH-NH[0])/0.10)
				tau_f  = tau[n0] + (tau[n0+1]-tau[n0])*(log_NH-NH[n0])/(NH[n0+1]-NH[n0])
			if (tau_f >= 0.): tau_f=0.
			return -tau_f * np.log(10.)
	else:
		return np.power(10.,log_NH) * cross_section(nu)

# load the optical-IR template, based on the observations in text and specifically 
#		 the Richards et al. 2006 mean blue SED 
def return_ratio_to_b_band(nu):
	double log_nu[226]={
12.50, 12.52, 12.54, 12.56, 12.58, 12.60, 12.62, 12.64, 12.66, 12.68, 12.70, 12.72, 12.74,
12.76, 12.78, 12.80, 12.82, 12.84, 12.86, 12.88, 12.90, 12.92, 12.94, 12.96, 12.98, 13.00,
13.02, 13.04, 13.06, 13.08, 13.10, 13.12, 13.14, 13.16, 13.18, 13.20, 13.22, 13.24, 13.26,
13.28, 13.30, 13.32, 13.34, 13.36, 13.38, 13.40, 13.42, 13.44, 13.46, 13.48, 13.50, 13.52,
13.54, 13.56, 13.58, 13.60, 13.62, 13.64, 13.66, 13.68, 13.70, 13.72, 13.74, 13.76, 13.78,
13.80, 13.82, 13.84, 13.86, 13.88, 13.90, 13.92, 13.94, 13.96, 13.98, 14.00, 14.02, 14.04,
14.06, 14.08, 14.10, 14.12, 14.14, 14.16, 14.18, 14.20, 14.22, 14.24, 14.26, 14.28, 14.30,
14.32, 14.34, 14.36, 14.38, 14.40, 14.42, 14.44, 14.46, 14.48, 14.50, 14.52, 14.54, 14.56,
14.58, 14.60, 14.62, 14.64, 14.66, 14.68, 14.70, 14.72, 14.74, 14.76, 14.78, 14.80, 14.82,
14.84, 14.86, 14.88, 14.90, 14.92, 14.94, 14.96, 14.98, 15.00, 15.02, 15.04, 15.06, 15.08,
15.10, 15.12, 15.14, 15.16, 15.18, 15.20, 15.22, 15.24, 15.26, 15.28, 15.30, 15.32, 15.34,
15.36, 15.38, 15.40, 15.42, 15.44, 15.46, 15.48, 15.50, 15.52, 15.54, 15.56, 15.58, 15.60,
15.62, 15.64, 15.66, 15.68, 15.70, 15.72, 15.74, 15.76, 15.78, 15.80, 15.82, 15.84, 15.86,
15.88, 15.90, 15.92, 15.94, 15.96, 15.98, 16.00, 16.02, 16.04, 16.06, 16.08, 16.10, 16.12,
16.14, 16.16, 16.18, 16.20, 16.22, 16.24, 16.26, 16.28, 16.30, 16.32, 16.34, 16.36, 16.38,
16.40, 16.42, 16.44, 16.46, 16.48, 16.50, 16.52, 16.54, 16.56, 16.58, 16.60, 16.62, 16.64,
16.66, 16.68, 16.70, 16.72, 16.74, 16.76, 16.78, 16.80, 16.82, 16.84, 16.86, 16.88, 16.90,
16.92, 16.94, 16.96, 16.98, 17.00
};
double log_nuLnu[226]={
44.39, 44.44, 44.50, 44.55, 44.60, 44.65, 44.70, 44.74, 44.78, 44.82, 44.86, 44.89, 44.92,
44.95, 44.97, 45.00, 45.02, 45.04, 45.06, 45.08, 45.10, 45.12, 45.14, 45.16, 45.17, 45.19,
45.20, 45.22, 45.23, 45.24, 45.25, 45.26, 45.27, 45.28, 45.29, 45.30, 45.31, 45.31, 45.32,
45.33, 45.34, 45.34, 45.35, 45.35, 45.36, 45.36, 45.37, 45.38, 45.38, 45.38, 45.39, 45.39,
45.39, 45.40, 45.40, 45.40, 45.40, 45.41, 45.41, 45.41, 45.41, 45.41, 45.41, 45.41, 45.41,
45.41, 45.40, 45.40, 45.40, 45.40, 45.40, 45.40, 45.39, 45.39, 45.38, 45.38, 45.37, 45.36,
45.35, 45.34, 45.33, 45.31, 45.30, 45.28, 45.26, 45.24, 45.22, 45.19, 45.17, 45.15, 45.13,
45.12, 45.11, 45.11, 45.11, 45.11, 45.12, 45.12, 45.13, 45.14, 45.15, 45.16, 45.18, 45.19,
45.20, 45.22, 45.23, 45.25, 45.26, 45.27, 45.28, 45.30, 45.32, 45.34, 45.36, 45.38, 45.40,
45.42, 45.44, 45.47, 45.49, 45.52, 45.55, 45.58, 45.60, 45.62, 45.64, 45.65, 45.65, 45.66,
45.66, 45.67, 45.68, 45.69, 45.71, 45.72, 45.74, 45.75, 45.77, 45.78, 45.79, 45.80, 45.80,
45.80, 45.80, 45.79, 45.77, 45.74, 45.71, 45.68, 45.64, 45.60, 45.57, 45.55, 45.52, 45.51,
45.49, 45.47, 45.46, 45.44, 45.42, 45.40, 45.38, 45.36, 45.34, 45.32, 45.29, 45.27, 45.25,
45.22, 45.20, 45.18, 45.15, 45.13, 45.11, 45.08, 45.06, 45.04, 45.02, 44.99, 44.97, 44.95,
44.92, 44.90, 44.88, 44.86, 44.83, 44.81, 44.79, 44.77, 44.74, 44.72, 44.70, 44.67, 44.65,
44.63, 44.61, 44.58, 44.56, 44.54, 44.52, 44.50, 44.47, 44.45, 44.43, 44.41, 44.40, 44.38,
44.36, 44.35, 44.33, 44.32, 44.30, 44.29, 44.28, 44.27, 44.27, 44.26, 44.26, 44.26, 44.26,
44.26, 44.25, 44.25, 44.25, 44.25
};

// want the ratio with respect to the intrinsic B-band:
double nu_BB = 14.833657;
double L_BB  = 45.413656;
double log_nu_obs = log10(nu);
double nuLnu_obs = 0.;

if (log_nu_obs < log_nu[0])   nuLnu_obs = log_nuLnu[0] + 2.0*(log_nu_obs - log_nu[0]);
if (log_nu_obs > log_nu[224]) nuLnu_obs = log_nuLnu[224];
	// assumes Gamma=2.0; the calling code will actually use X-ray template for this case
if ((log_nu_obs>=log_nu[0])&&(log_nu_obs<=log_nu[224])) {
	int n0 = (int )((log_nu_obs-log_nu[0])/0.02);
	nuLnu_obs = log_nuLnu[n0] + (log_nuLnu[n0+1]-log_nuLnu[n0]) * 
									((log_nu_obs-log_nu[n0])/(log_nu[n0+1]-log_nu[n0]));
}
return pow(10.0,nuLnu_obs-L_BB);
}




# load the x-ray template, based on the observations in text and 
#     specifically the Magdziarz & Zdziarski 1995 PEXRAV model with Gamma=1.8 
#     (Tozzi et al., George et al.), theta=2pi, solar abundances
def return_ratio_to_hard_xray(nu):
	double log_nu[275]={
16.00, 16.02, 16.04, 16.06, 16.08, 16.10, 16.12, 16.14, 16.16, 16.18, 16.20, 16.22, 16.24,
16.26, 16.28, 16.30, 16.32, 16.34, 16.36, 16.38, 16.40, 16.42, 16.44, 16.46, 16.48, 16.50,
16.52, 16.54, 16.56, 16.58, 16.60, 16.62, 16.64, 16.66, 16.68, 16.70, 16.72, 16.74, 16.76,
16.78, 16.80, 16.82, 16.84, 16.86, 16.88, 16.90, 16.92, 16.94, 16.96, 16.98, 17.00, 17.02,
17.04, 17.06, 17.08, 17.10, 17.12, 17.14, 17.16, 17.18, 17.20, 17.22, 17.24, 17.26, 17.28,
17.30, 17.32, 17.34, 17.36, 17.38, 17.40, 17.42, 17.44, 17.46, 17.48, 17.50, 17.52, 17.54,
17.56, 17.58, 17.60, 17.62, 17.64, 17.66, 17.68, 17.70, 17.72, 17.74, 17.76, 17.78, 17.80,
17.82, 17.84, 17.86, 17.88, 17.90, 17.92, 17.94, 17.96, 17.98, 18.00, 18.02, 18.04, 18.06,
18.08, 18.10, 18.12, 18.14, 18.16, 18.18, 18.20, 18.22, 18.24, 18.26, 18.28, 18.30, 18.32,
18.34, 18.36, 18.38, 18.40, 18.42, 18.44, 18.46, 18.48, 18.50, 18.52, 18.54, 18.56, 18.58,
18.60, 18.62, 18.64, 18.66, 18.68, 18.70, 18.72, 18.74, 18.76, 18.78, 18.80, 18.82, 18.84,
18.86, 18.88, 18.90, 18.92, 18.94, 18.96, 18.98, 19.00, 19.02, 19.04, 19.06, 19.08, 19.10,
19.12, 19.14, 19.16, 19.18, 19.20, 19.22, 19.24, 19.26, 19.28, 19.30, 19.32, 19.34, 19.36,
19.38, 19.40, 19.42, 19.44, 19.46, 19.48, 19.50, 19.52, 19.54, 19.56, 19.58, 19.60, 19.62,
19.64, 19.66, 19.68, 19.70, 19.72, 19.74, 19.76, 19.78, 19.80, 19.82, 19.84, 19.86, 19.88,
19.90, 19.92, 19.94, 19.96, 19.98, 20.00, 20.02, 20.04, 20.06, 20.08, 20.10, 20.12, 20.14,
20.16, 20.18, 20.20, 20.22, 20.24, 20.26, 20.28, 20.30, 20.32, 20.34, 20.36, 20.38, 20.40,
20.42, 20.44, 20.46, 20.48, 20.50, 20.52, 20.54, 20.56, 20.58, 20.60, 20.62, 20.64, 20.66,
20.68, 20.70, 20.72, 20.74, 20.76, 20.78, 20.80, 20.82, 20.84, 20.86, 20.88, 20.90, 20.92,
20.94, 20.96, 20.98, 21.00, 21.02, 21.04, 21.06, 21.08, 21.10, 21.12, 21.14, 21.16, 21.18,
21.20, 21.22, 21.24, 21.26, 21.28, 21.30, 21.32, 21.34, 21.36, 21.38, 21.40, 21.42, 21.44,
21.46, 21.48 
};
double log_nuLnu[275]={
-2.1132, -2.1092, -2.1052, -2.1012, -2.0972, -2.0932, -2.0892, -2.0852, -2.0812, -2.0772, -2.0732, 
-2.0692, -2.0652, -2.0612, -2.0572, -2.0532, -2.0492, -2.0452, -2.0412, -2.0372, -2.0332, -2.0292, 
-2.0252, -2.0212, -2.0172, -2.0132, -2.0092, -2.0052, -2.0012, -1.9972, -1.9932, -1.9892, -1.9852, 
-1.9812, -1.9772, -1.9732, -1.9692, -1.9652, -1.9611, -1.9571, -1.9531, -1.9491, -1.9452, -1.9412, 
-1.9372, -1.9332, -1.9292, -1.9252, -1.9212, -1.9172, -1.9132, -1.9092, -1.9052, -1.9012, -1.8971, 
-1.8931, -1.8894, -1.8854, -1.8814, -1.8774, -1.8734, -1.8694, -1.8654, -1.8614, -1.8574, -1.8534, 
-1.8495, -1.8455, -1.8415, -1.8374, -1.8334, -1.8294, -1.8253, -1.8213, -1.8172, -1.8132, -1.8091, 
-1.8050, -1.8009, -1.7968, -1.7927, -1.7885, -1.7843, -1.7803, -1.7761, -1.7718, -1.7675, -1.7631, 
-1.7587, -1.7547, -1.7502, -1.7457, -1.7410, -1.7363, -1.7314, -1.7266, -1.7215, -1.7163, -1.7109, 
-1.7053, -1.6999, -1.6940, -1.6878, -1.6814, -1.6747, -1.6677, -1.6604, -1.6527, -1.6451, -1.6369, 
-1.6283, -1.6194, -1.6342, -1.6266, -1.6188, -1.6113, -1.6036, -1.5950, -1.5861, -1.5763, -1.5655, 
-1.5530, -1.5391, -1.5253, -1.5116, -1.4968, -1.4808, -1.4635, -1.4451, -1.4259, -1.4062, -1.3867, 
-1.3676, -1.3494, -1.3323, -1.3165, -1.3021, -1.2891, -1.2775, -1.2671, -1.2580, -1.2501, -1.2432, 
-1.2372, -1.2320, -1.2277, -1.2240, -1.2210, -1.2185, -1.2166, -1.2152, -1.2143, -1.2141, -1.2144, 
-1.2150, -1.2160, -1.2172, -1.2188, -1.2207, -1.2229, -1.2253, -1.2280, -1.2310, -1.2342, -1.2376, 
-1.2413, -1.2453, -1.2495, -1.2540, -1.2588, -1.2640, -1.2694, -1.2752, -1.2814, -1.2881, -1.2952, 
-1.3028, -1.3109, -1.3196, -1.3289, -1.3389, -1.3496, -1.3609, -1.3731, -1.3861, -1.4000, -1.4148, 
-1.4302, -1.4456, -1.4602, -1.4741, -1.4877, -1.5012, -1.5147, -1.5284, -1.5424, -1.5567, -1.5714, 
-1.5866, -1.6023, -1.6186, -1.6354, -1.6529, -1.6711, -1.6901, -1.7098, -1.7304, -1.7518, -1.7742, 
-1.7975, -1.8219, -1.8474, -1.8740, -1.9018, -1.9308, -1.9612, -1.9930, -2.0263, -2.0611, -2.0975, 
-2.1356, -2.1755, -2.2173, -2.2611, -2.3070, -2.3551, -2.4055, -2.4584, -2.5138, -2.5720, -2.6331, 
-2.6971, -2.7642, -2.8347, -2.9087, -2.9864, -3.0678, -3.1533, -3.2430, -3.3371, -3.4358, -3.5394, 
-3.6481, -3.7620, -3.8814, -4.0067, -4.1382, -4.2760, -4.4205, -4.5719, -4.7306, -4.8971, -5.0716, 
-5.2545, -5.4462, -5.6471, -5.8576, -6.0783, -6.3096, -6.5520, -6.8059, -7.0719, -7.3506, -7.6428, 
-7.9489, -8.2696, -8.6055, -8.9574, -9.3260, -9.7124, -10.1171, -10.5410, 
-10.9850, -11.4499, -11.9371};

// want the ratio with respect to the intrinsic 2-10 keV:
double L_HX  = -1.47406;
double log_nu_obs = log10(nu);
double nuLnu_obs = 0.;

if (log_nu_obs < log_nu[0])   nuLnu_obs = log_nuLnu[0];
if (log_nu_obs > log_nu[273]) nuLnu_obs = -2.0 - pow(10.0,log_nu_obs-20.1204)*(0.43429448);
if ((log_nu_obs>=log_nu[0])&&(log_nu_obs<=log_nu[273])) {
	int n0 = (int )((log_nu_obs-log_nu[0])/0.02);
	nuLnu_obs = log_nuLnu[n0] + (log_nuLnu[n0+1]-log_nuLnu[n0]) * 
									((log_nu_obs-log_nu[n0])/(log_nu[n0+1]-log_nu[n0]));
}
return pow(10.0,nuLnu_obs-L_HX);
}
